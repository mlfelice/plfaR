# R script for PLFA analysis package


# QA functions:
#   1. Make sure 16:0, 13:0, and 19:0 are present in all samples
#   2. Make sure there are no duplicate names in any samples
#   3a. Count number of named peaks in each sample
#   3b. Calculate distribution of each peak in samples (% samples with peak name)
# Now we should wrap these in single quality_function

#check_quality <- function(df){
  #
#  qc_df <- df %>%
#    group_by(DataFileName, BiomarkerFinal) %>%
#    summarise(Count = n()) #%>%
  #spread(key = BiomarkerFinal, value = Count)
#}

find_duplicate <- function(df){

  duplicates_df <- df %>%
    group_by(DataFileName, Name) %>%
    summarise(Count = n()) %>%
    filter(Count > 1)
  
  if(any(duplicates_df[['Count']] > 1)){
    cat('Warning: Duplicate peaks detected.Check naming before proceeding\n')
    #cat(duplicates_df[which(duplicates_df[['Count']] > 1),][['DataFileName']])
  }
  
  return(duplicates_df)
}

find_missing <- function(df, lipids = c('13:0', '16:0', '19:0')){
  # input df must be grouped by DataFileName for this to work properly
  # This should now work without going through the intermediate check_quality() step

  biomarkers <- unique(df[['Name']])
  
  missing_std_df <- df %>%
    group_by(DataFileName) %>%
    complete(Name = !!biomarkers) %>% # Makes missing vals explicit
    filter(is.na(TotalPeakArea1) & Name %in% !!lipids) %>%
    select(Batch, DataFileName, Name)
    
  if(nrow(missing_std_df) > 0){
    cat('Warning: Standards missing from at least one sample.\n')
    cat('Check data file and/or chromatograms before proceeding\n')
    #cat(missing_std_df[which(missing_std_df[['Count']] > 1),][['DataFileName']])
    }
  
  return(missing_std_df)

}

count_lipids <- function(df){

  n_samples <- length(unique(df[['DataFileName']]))
  
  lipid_freq_df <- df %>%
    mutate(Count = 1) %>%
    group_by(Name) %>%
    summarise(LipidFrequency = sum(Count)/!!n_samples)
  
  return(lipid_freq_df)
}

quality_check <- function(df){
  
  
  qa_funs <- list(duplicate_lipids = find_duplicate, missing_lipids = find_missing, 
          lipid_frequency = count_lipids)
  
  qa_stats_list <- lapply(qa_funs, function(f){f(df)})
  names(qa_stats_list) <- c('duplicate_peak_names', 'missing_standard_peaks',
                            'lipid_distribution')
  
  return(qa_stats_list)
  
}

# 1. Load packages ####
#----------------------
library(tidyverse)
library(readxl)
library(writexl)
library(reshape2)
library(stringr)

# 2. Define functions ####
# ------------------------
# Import function. One option is to take peak list as input, then make the main object
# a wide format dataframe. Only issue is that this is less convenient for manipulations,
# which for us use dplyr

# Maybe instead, we just have a display function that converts to wide
load_batch <- function(file_path){
  # This function imports named peak list for downstream processing/analysis
  #
  # Args: 
  #   file_path: This is the full path+filename of source data
  #     - Input file should be in Excel format (xlsx or xls ok)
  #     - If more than one worksheet, relevant data must be 
  #       included in tabs with following names:
  #       - 'named_peaks'
  #     - File should have the following columns with headers:
  #       - Batch
  #       - DataFileName
  #       - RetTimeSecs
  #       - MajorHeightnA
  #       - TotalPeakArea1
  #       - DisplayDelta1
  #       - Name
  #
  # To do: include data checks:
  #   - file format is correct
  #   - if more than one tab, make sure tab name is present
  #   - Make check peak names against the reference peak list
  #     - ensures that no mistakes in typing peaks (ie. extra spaces, etc)
  read_xlsx(file_path, sheet = 'named_peaks', na = 'NA') %>%
    select(-BiomarkerRTBased, -Notes) %>%
    filter(!is.na(BiomarkerFinal) %>% # Remove unnamed peaks
    # add if statement so that if there is no batch column, but batch name is in 
      #filename, it can create a batch column
    mutate(DisplayDelta1 = as.numeric(DisplayDelta1)) %>% #,
           #Batch = str_extract(string = file_path, pattern = '[Bb]atch ?[0-9]+'),
           #BatchDataFileName = paste(Batch, DataFileName, sep = '_')) %>% # ? looks for 0 or 1)
    select(Batch, DataFileName, BatchDataFileName, everything()) # Ensure order
}

#####
normalize_area <- function(df){ # Need to remove standards from this calculation
  cf_numerator_df <- df %>% 
    group_by(Batch, DataFileName, BatchDataFileName, BiomarkerFinal) %>% #in case dups here on purpose, this merges them
    summarise(TotalPeakArea1 = sum(TotalPeakArea1)) %>%
    ungroup() %>%
    filter(!str_detect(DataFileName, 'Internal|M1M2|FAME')) %>%
    group_by(BatchDataFileName) %>%
    mutate(AllLipidArea = sum(TotalPeakArea1)) %>%
    ungroup %>% 
    group_by(Batch) %>%
    mutate(MeanBatchArea = mean(AllLipidArea)) %>% 
    ungroup() %>%
    filter(MeanBatchArea == min(MeanBatchArea)) %>%
    group_by(BiomarkerFinal) %>%
    summarise(CFNumerator = mean(TotalPeakArea1))
  
  df %>% #group_by(Batch, BiomarkerFinal) %>%
    #summarise(BatchMeanPeakArea = mean(TotalPeakArea1, na.rm = TRUE)) %>%
    group_by(Batch, DataFileName, BatchDataFileName, BiomarkerFinal) %>% #in case dups here on purpose, this merges them
    summarise(TotalPeakArea1 = sum(TotalPeakArea1)) %>%
    ungroup() %>%
    left_join(cf_numerator_df, by = 'BiomarkerFinal') %>%
    group_by(Batch, BiomarkerFinal) %>%
    mutate(CFactor = CFNumerator / mean(TotalPeakArea1[!str_detect(DataFileName, 'Internal|M1M2|FAME')])) %>%
    #right_join(df, by = c('Batch', 'BiomarkerFinal')) %>%
    mutate(NormalizedArea = TotalPeakArea1 * CFactor)  ### changed 8/15/2019
  
  #should also add something to make CF values = 1 if there are no samples for denominator
  #had to add some lines to remove teh standards from these calculations
}

normalize_area <- function(df){
  cf_numerator_df <- df %>%  # this df seems to figure out the peak area of the largest
    group_by(BatchDataFileName) %>%
    mutate(AllLipidArea = sum(TotalPeakArea1)) %>%
    ungroup %>% 
    group_by(Batch) %>%
    mutate(MeanBatchArea = mean(AllLipidArea)) %>% 
    ungroup() %>%
    filter(MeanBatchArea == max(MeanBatchArea)) %>%
    group_by(BiomarkerFinal) %>%
    summarise(CFNumerator = mean(TotalPeakArea1))
  
  df %>% #group_by(Batch, BiomarkerFinal) %>%
    #summarise(BatchMeanPeakArea = mean(TotalPeakArea1, na.rm = TRUE)) %>%
    left_join(cf_numerator_df, by = 'BiomarkerFinal') %>%
    group_by(Batch, BiomarkerFinal) %>%
    mutate(CFactor = CFNumerator / mean(TotalPeakArea1)) %>%
    #right_join(df, by = c('Batch', 'BiomarkerFinal')) %>%
    mutate(NormalizedArea = TotalPeakArea1 * CFactor)  ### changed 8/15/2019

  
}
# R values match Excel values through here ('Norm. Peak Areas' sheet)

subtract_blanks <- function(df, biomarkers = c('13:0', '19:0')){  # version that subtracts average of all peak area in that batch
  all_biomarkers <- unique(df[['BiomarkerFinal']])
  
  df %>% ungroup() %>% 
    group_by(DataFileName) %>%
    complete(BiomarkerFinal = !!all_biomarkers, fill = list(NormalizedArea = 0)) %>% # May eventually move to the loading function, if we decide to treat all blanks as 0 for all averages
    fill(Batch) %>%
    ungroup() %>%
    group_by(Batch, BiomarkerFinal) %>%
    mutate(AreaMinusBlank = if_else(BiomarkerFinal %in% biomarkers, 
                                    NormalizedArea-mean(NormalizedArea[!str_detect(DataFileName, 'Internal|M1M2|FAME')]), 
                                    NormalizedArea),
           AreaMinusBlank = if_else(AreaMinusBlank < 0, 0, AreaMinusBlank)#,
           #AreaToSubtract = mean(NormalizedArea)
           )
  #as above, modified to exclude standards from teh 13:0 average
}

subtract_blanks <- function(df, blanks = c('100.raw', '101.raw'), 
                            biomarkers = c('13:0', '19:0')){  # version that subtracts avg of blanks only
  
  blanks_df <- df %>% 
    filter(DataFileName %in% blanks) %>%
    group_by(BiomarkerFinal) %>%
    mutate(BlankArea = if_else(BiomarkerFinal %in% biomarkers, mean(TotalPeakArea1), 0)) %>%
    select(BiomarkerFinal, BlankArea)
  
  df %>% ungroup() %>% 
    left_join(blanks_df, by = 'BiomarkerFinal') %>%
    mutate(BlankArea = if_else(is.na(BlankArea), 0, BlankArea)) %>%
    group_by(Batch, BiomarkerFinal) %>%
    mutate(AreaMinusBlank = if_else(NormalizedArea - BlankArea < 0, 0,
                                    NormalizedArea - BlankArea))
}

apply_kval <- function(df, standard_fnames, mw_df, standard_conc = 250, inj_vol = 2, #standard_fnames should be blanks, not 13:0 standard, I think
                       standard = '13:0', soil_wt_df, vial_vol = 50){
  kval_df <- df[which(df[['DataFileName']] %in% standard_fnames &
                        df[['BiomarkerFinal']] == standard),] %>%
    group_by(BiomarkerFinal) %>% # took this away, b/c Jess uses single K-value/ whole set
    mutate_at(vars(NormalizedArea), funs(StandardArea = mean(., na.rm = TRUE))) %>%  # intra-batch mean of blanks
    ungroup() %>%
    #rename(StandardArea = NormalizedArea, StandardBiomarker = BiomarkerFinal) %>%  # rename so distinct after join
    rename(StandardBiomarker = BiomarkerFinal) %>%  # rename so distinct after join
    #group_by(Batch, Biomarker) %>%
    # currently makes one kval/batch, Jess version of Excel uses single kval for all
    mutate(kval = StandardArea / !!standard_conc / !!inj_vol) %>%  # calc kval - one/batch
    #filter(Biomarker == standard & !is.na(Batch)) %>%
    select(StandardBiomarker, StandardArea, kval)
  
  kval <- kval_df[['kval']][[1]]
  
  nmol_df <- df %>%  
    mutate(kval = !!kval) %>%
    left_join(mw_df, by = c('BiomarkerFinal' = 'FAME ID')) %>%
    #select(-Batch) %>%
    left_join(samp_wt_df, by = 'DataFileName') %>%
    mutate(nmol_g = (NormalizedArea / kval) * (!!vial_vol / 2) / 
             (`Molecular weight (g/mol)` * SampleWt)) 
  return(nmol_df)

}

calc_biomarkers <- function(df){
    f_lipids <- c('16:1 w5c', '18:1 w9c', '18:2 w6,9c')
    b_lipids <- c('13:0 iso', '13:0 anteiso', '14:0 3OH', '15:0 iso', '15:0 anteiso', 
                  '16:0 iso', '16:1 w7c', '16:0 10me', '17:0 iso', '17:0 anteiso', 
                  '18:1 w9t', '18:1 w7c', '18:0 10me')
    
    df <- df %>% group_by(BatchDataFileName) %>% 
      mutate(TotalBiomass = sum(nmol_g[!is.na(Indicates)], na.rm = TRUE),
             TotalFungi = sum(nmol_g[BiomarkerFinal %in% !!f_lipids], na.rm = TRUE),
             TotalBact = sum(nmol_g[BiomarkerFinal %in% !!b_lipids], na.rm = TRUE),
             FungiToBact = TotalFungi / TotalBact,
             PercentFungi = TotalFungi / TotalBiomass * 100,
             PercentBact = TotalBact / TotalBiomass * 100
      )
    return(df)
    
  }

clean_nmol_df <- function(df){
  clean_df <- df %>% 
    mutate(Replicate = str_extract(SampleID, '(?<=[0-9])[A-Za-z]*(?=_)'),
           Year = str_extract(SampleID, '(?<=_)[0-9]+(?=_)'),
           Plot = str_extract(SampleID, '^[0-9]+(?=-)'),
           DepthNum = str_extract(SampleID, '(?<=-)[0-9](?=[A-Za-z])')) %>%
    select(-c(kval, NormalizedArea, `Molecular weight (g/mol)`, SampleWt))
  return(clean_df)
}

