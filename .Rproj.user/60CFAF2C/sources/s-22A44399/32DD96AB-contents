# Date created: 5/16/2019
# Last modified: 7/26/2019
#
#Asdflkj;sldakf;sdlaf;lkasdjf;dlkjas;lkj;dlkja;slkdjfasdfkdsljlsadk-80characters
#
# Purpose: automate conversion of IRMS peak area to lipid concentration
#
# 1. Peak identification
#   a. Quality check - confirm following markers are present in all samples: 13:O, 16:O, 19:O
#   b. Quality check - confirm that all biomarkers are in most samples (we can calculated a % blank cells)
#   c. Quality check - confirm that no biomarkers are listed twice - this should be easy in R (unique == names, or something)
#   
# 2. Quantification
#   a. combine all data from different batches and reshape
#     i. rows = sample, cols = biomarker, values = sum peak area
#     ii. Will probably also have to filter out some unwanted data fields
#   b. convert peak areas to nmol (this is the "PLFA Protocol for nmol calculation..." doc)
#     i. calculated fractional difference between batches
#       - for each column: average peak area for batch/highest peak area for all batches --> "fraction difference"
#       - normalize peak areas using the "fraction difference"
#         - Multiply by the "fraction difference" you just calculated
#          - Subtract average of the values of blanks 13:O and 19:O
#       - Generate K-factor by dividing the 13:O standard for each batch by conc in ng/uL*uL sample injected
#

##### Need to modify to work with multiple batches #####


# 1. Load packages ####
#----------------------
library(tidyverse)
library(readxl)
library(writexl)
library(reshape2)

# 2. Define functions ####
# ------------------------
id_dups <- function(df, start_col = 2){
  # 
  # function checks and outputs biomarkers with duplicate entries within sample
  #
  # Args:
  #   df: dataframe of counts of peaks, wide format (cols = biomarkers, rows = samples)
  #   start_col: the first column containing biomarkers
  #
  # Returns:
  #   list of biomarkers and samples with duplicate biomarkers (if any)
  #
  # 
  dup_names <- lapply(df[,start_col:ncol(df)], FUN = function(x){any(x > 1)})
  dup_ls <- vector('list', length = length(names(which(dup_names == TRUE))))
  names(dup_ls) <- names(which(dup_names == TRUE))
  
  if(sum(unlist(dup_names)) == 0){ # Alternative to isFALSE (doesn't work)
    print('No duplicate peak names identified')
  }

  else{
    for(i in names(which(dup_names == TRUE))){
      dup_ls[[i]] <- df[which(df[i] > 1),1]
    }
  }
  return(dup_ls)
}

find_miss <- function(df, lipids = c('13:0', '16:0', '19:0')){ 
  #
  # Returns lists for each lipid of samples without that lipid
  #
  # Args:
  #   df:
  #   lipids:
  #
  # Returns:
  #   returns a list of standard? lipids containing vector of samples 
  #      not containing it
  #
  
  # Initialize empty list to store results
  no_lipid <- vector('list', length = length(lipids)) 
  names(no_lipid) <- lipids  # Name list items after specified lipids
  
  for(l in lipids){  # loop through list of lipids argument
    #print(l)
    # subset dataframe to pull each sample name missing that lipid
    no_lipid[[l]] <- df[which(df[l] == 0), 1]
  }
  
  return(no_lipid)
}

count_lips <- function(df, start_col = 2){ 
  #
  # determines detection freqeuncy for each lipid in input dataframe
  #
  # Args:
  #   df: dataframe with # of peaks for each biomarker (cols) and sample (rows)
  #   start_col: first column containing biomarker
  # 
  # Returns:
  #   dataframe listing the detection frequency for each biomarker (rows)
  
  df_trim <- df[,start_col:ncol(df)] # Subset dataframe (remove sample name column)
  column_names <- vector(length = ncol(df_trim)) # Empty vector to house sample names
  lipid_freq <- vector(length = ncol(df_trim)) # Empty vector to house freq vals
  
  for(i in 1:ncol(df_trim)){ # Loop through all cols to calc frequency of detection
    column_names[i] <- names(df_trim)[i]
    lipid_freq[i] <- sum(df_trim[[i]])/length(df_trim[[i]])
  }
  
  lipid_freq_df <- tibble(Lipid = column_names, Detection_freq = lipid_freq) # Make dataframe from vecs
  
  print(lipid_freq_df)
}

# Transform values in the batch dataframe (a) by multiplying by the correction factor/fractional difference from max
normalize_area <- function(df, frac_area_df, batches, start_col = 2){
  
  i = start_col
  
  for(b in batches){
    cf <- frac_area_df[!is.na(frac_area_df$batch) & frac_area_df$batch == b,
                        ][[i]]
    
    normalized_df <- df
    
    normalized_df[!is.na(normalized_df$batch) & normalized_df$batch == b, 
                  ][[i]] <- normalized_df[!is.na(normalized_df$batch) & 
                                            normalized_df$batch == b, 
                                          ][[i]] * cf  
  }
  return(normalized_df)
}

subt_stand <- function(df, stand_df){

  for(s in unique(stand_df[['biomarker']])){
    #search_string <- paste0(str_extract(s, '[0-9]+'), '.[Ss]tandard')
    fnames_df <- subset(stand_df, biomarker == s)
    stand_vec <- df[which(df$DataFileName %in% fnames_df[['name']]), s]
    #stand_vec <- df[which(str_detect(df[ ,2], ls1[ls1$biomarker == s, 2])), 
    #                which(names(df) == s)]
    stand_val <- mean(stand_vec)

    df[, which(names(df) == s)] <- 
      df[, which(names(df) == s)] - stand_val
    df[df[[s]] < 0, which(names(df) == s)] <- 0
  }
  return(df)
}

get_mw <- function(df, marker){
  # Returns the molecular weight of specified biomarker
  #
  # Args:
  #   df: reference dataframe containing biomarker names and molecular weight
  #   marker: the biomarker whose molecular weight you want to look up
  #
  # Returns:
  #   molecular weight of specified biomarker (numeric)
  #
  df[which(df$`FAME ID` == marker), 2][[1]]
}

apply_k <- function(df, stand_df, mwt_df, standard_conc = 250, inj_vol = 2, 
                    standard = '13:0', soil_mass = 1, vial_vol = 20, 
                    start_col = 2){
  # Converts the peak area to lipid concentration
  #
  # Args:
  #   df: dataframe of normalized peak areas with 13:0 and 19:0 subtracted
  #   stand_df: dataframe identifying filenames for standards
  #   mwt_df: reference dataframe containing molecular weights of biomarkers
  #   standard_conc: concentration (nmol/uL) of specified standard used
  #   inj_vol: volume of specified standard injected
  #   standard: lipid standard used for area to conc calculation
  #   vial_vol: total volume in GC vial
  #   start_col: index of column with first biomarker
  #
  # Returns: 
  #   dataframe containing total biomass
  temp_df <- df[, 3:ncol(df)]  # Remove sample names from dataframe
  
  fnames_df <- subset(stand_df, biomarker == standard)
  stand_vec <- df[which(df$DataFileName %in% fnames_df[['name']]), standard]
  stand_val <- mean(stand_vec)
  kval <- stand_val / standard_conc / inj_vol
  
  for(i in mwt_df[[1]]){  # First column of reference dataframe (biomarker names)
    mw <- get_mw(mwt_df, i)
    df[i] <- (df[[i]] / kval) * (vial_vol / 2) / (mw * soil_mass)
  }

  
  cat('No reference molecular weight for: \n\n')
  print(
    names(df[,4:ncol(df)])[which(!names(df[,4:ncol(df)]) %in% mwt_df[[1]])]
  )
  
  df <- df %>% mutate(
    #total_biomass = select_(.dots = match(mwt_df[[1]], names(df))) %>% rowSums) %>%
    total_biomass = rowSums(select(df, which(names(.) %in% mwt_df[[1]])), 
                            na.rm = TRUE)) #%>%
    #select(batch, DataFileName, total_biomass)
  
  return(df)
  
}

# 3. Load raw data for single batch ####
#---------------------------------------
source_path <- file.choose()

batch_raw_df <- read_xlsx(source_path, sheet = 'named_peaks', na = 'NA') %>%
  select(-BiomarkerRTBased, -Notes)

# Cols in the df used to develop this script:
# ID_With batch
# Name
# RT (Sec)
# Height (nA)
# Corrected 13C
# Peak Name
# Sum Peak Area

# Add batch #
batch_raw_df['ID'] <- 7


# 4. Quality check ####

batch_narm_df <- batch_raw_df[!is.na(batch_raw_df$BiomarkerFinal),] # Remove unnamed peaks (may not ultimately want to do this)

#### Aggregate data - counts of biomarker (cols) in ID'd in each sample (rows) ####
qc_df <- dcast(batch_narm_df, DataFileName ~ BiomarkerFinal, 
                       value.var = 'TotalPeakArea1', 
                       fun.aggregate = length)  # Make wide and aggregate
#### Aggregate data - counts of biomarker (rows) in ID'd in each sample (cols) ####
qc_df2 <- dcast(batch_narm_df, BiomarkerFinal ~ DataFileName, 
                       value.var = 'TotalPeakArea1', 
                       fun.aggregate = length)  # Make wide and aggregate

##### Only for testing the script #####
# upload pivot table quality check to compare to our R method above
batch14_QC_df <- read_xlsx(source_path, sheet = 'SPRUCE Batch 14_QC', 
                           skip = 3, na = '') %>%
  mutate_all(.funs = funs(ifelse(is.na(.), 0, .))) %>% # Syntax from SO, need to figure out why this works
  select(-`(blank)`, -`Grand Total`) %>%
  rename(`Name` = `Row Labels`) %>%
  filter(!`Name` %in% c('(blank)', 'Grand Total'))

# Ensure that our R aggregation is equivalent of pivot table in Excel (for script dev only)
all_equal(batch14_QC_df[order(batch14_QC_df$`Name`),], 
          qc_df[order(qc_df$`Name`),], convert = TRUE) # "convert = TRUE" ignores value class
#####

# check dataframe for entries > 1 (this means peak was named twice)
id_dups(qc_df)
id_dups(qc_df2)

# check to see that 16:O, 13:O, & 19:O in each sample 
find_miss(qc_df)

# sum each column and divide by nrow to determine the percentage of samples with a named peak
lip_freq_df <- count_lips(qc_df)

# In the future, I think we should combine these into one function that reads files, quality checks, merges batches, 
# and outputs a quality report

# 5. nanomole calculations (normalize values) ####
#-------------------------------------------------
areaw_df <- dcast(batch_narm_df, DataFileName ~ BiomarkerFinal,  # make wide
          value.var = 'TotalPeakArea1', fun.aggregate = sum) %>%  # vals don't change
  mutate(batch = as.character(7)) %>% #str_extract(`ID_With batch`, '[a-zA-Z0-9]\\d+(?=_)')) # Make column for batch ID; may need to get batch some other way, as not all include bath name
  select(-everything(), batch, everything())

#frac_diff <- function(x){
#  max(x)
#}

c_names <- names(areaw_df)[3:nrow(areaw_df)]

# Make dataframe with batch mean peak area for all biomarkers
area_frac_df <- areaw_df %>% group_by(Batch) %>%
  summarise_at(c_names, funs(mean), na.rm = TRUE)# %>%
#summarise_at(c_names, funs(frac_diff))

# Calculate fractional difference (relative to max)
area_frac_df <- bind_cols(area_frac_df[,1], # Create dataframe of correction factors
                            as_tibble(lapply(area_frac_df[,2:ncol(area_frac_df)], 
                                             function(x){max(x)/x})))

# Transform values in the batch dataframe (a) by multiplying by the correction factor/fractional difference from max
normalized_area_df = normalize_area(df = areaw_df, frac_area_df = area_frac_df,
                                    batches = c('5'), start_col = 3)


#batches <- c('B14')
#i = 2
#for(b in batches){
#  cf <- area_frac_df[!is.na(area_frac_df$batch) & area_frac_df$batch == b, ][[i]]
#  
#  a[!is.na(a$batch) & a$batch == b, ][[i]] <- a[!is.na(a$batch) & a$batch == b, ][[i]] * cf

# Subtract values of blanks 13:0 and 19:0 if difference > 0 ---> Not totally sure I understand this step


# Make dataframe containing biomarkers and associated file names
ls1 <- data.frame(biomarker = c('13:0', '13:0'), 
                  name = c('Internal std 1.raw', 'Internal std 2.raw'),
                  stringsAsFactors = FALSE)  # Make df w/samp names of markers

stands_sub_df <- subt_stand(normalized_area_df, stand_df = ls1)
#Asdflkj;sldakf;sdlaf;lkasdjf;dlkjas;lkj;dlkja;slkdjfasdfkdsljlsadk-80characters
# Calculate K-value and apply it to peak areas (this converts to nmol/__, etc)
mwt_ref_path <- 'C:/Users/Mark/Dropbox/umn_gutknecht_postdoc/spruce_project/plfa_13c/20190521_spruce_plfa_biomarker-molecular-wt.xlsx'
mwt_ref_df <- read_xlsx(mwt_ref_path)

mwt_ref_df <- mwt_ref_df[2:nrow(mwt_ref_df), ]

nmol_df <- apply_k(normalized_area_df, stand_df = ls1, mwt_ref_df)

# Calculate % of total biomass and append as final column
#nmol_df <- nmol_df %>% mutate(
#  total_biomass = rowSums(select(., -batch, -DataFileName), na.rm = TRUE)) %>%
#  select(batch, DataFileName, total_biomass, `10:0`:`8:0`)

# Convert biomarker concentrations to % of total biomass
perc_df <- bind_cols(nmol_df['Batch'], nmol_df['DataFileName'],
                     lapply(nmol_df[, 4:(ncol(nmol_df))], 
                            function(x){x/nmol_df[['total_biomass']] * 100})) 

# Calculate fungal:bacterial ratio  -- This needs work
f_lipids <- c('16:1 w5c', '18:1 w9c', '18:2 w6,9c')
b_lipids <- c('13:0 iso', '13:0 anteiso', '14:0 3OH', '15:0 iso', '15:0 anteiso', 
              '16:0 iso', '16:1 w7c', '16:0 10me', '17:0 iso', '17:0 anteiso', 
              '18:1 w9t', '18:1 w7c', '18:0 10me')

# Calculate and add percent fungi,bacteria, and fungal:bacterial ratio
perc_df['fungi_conc'] <- rowSums(nmol_df[, f_lipids], na.rm = TRUE)
perc_df['bact_conc'] <- rowSums(nmol_df[,b_lipids[b_lipids %in% names(nmol_df)]],
                                na.rm = TRUE)
perc_df['fb'] <- perc_df['fungi_conc']/perc_df['bact_conc']
perc_df['fungi_perc'] <- perc_df['fungi_conc']/nmol_df['total_biomass'] * 100
perc_df['bact_perc'] <- perc_df['bact_conc']/nmol_df['total_biomass'] * 100


# Export to Excel file:

##### END #####

# Calculate fungal to bacterial ratio
f_to_b <- nmol_df 
f_to_b['fungi'] <- rowSums(f_to_b[,f_lipids], na.rm = TRUE)
f_to_b['bacteria'] <- rowSums(f_to_b[,b_lipids[b_lipids %in% names(nmol_df)]], 
                              na.rm = TRUE)
f_to_b['fb'] <- f_to_b['fungi']/f_to_b['bacteria']
f_to_b <- f_to_b %>% select(batch, DataFileName, fungi, bacteria, fb)



#subt_stand <- function(df, stand_df){
no_stand_df <- df

for(s in stand_df[['biomarker']]){
  #search_string <- paste0(str_extract(s, '[0-9]+'), '.[Ss]tandard')
  # Uses the 2nd column (filename of stand_df) as search term
  # Finds row in peak list df with a matching filename
  # Returns dataframe entry with that row, and col corresponding to biomarker
  stand_vec <- df[which(str_detect(df[ ,2], ls1[ls1$biomarker == s, 2])), 
                  which(names(df) == s)]
  stand_val <- mean(stand_vec)
  
  df[, which(names(df) == s)] <- 
    df[, which(names(df) == s)] - stand_val
  df[df[[s]] < 0, which(names(df) == s)] <- 0
}
return(df)
}
